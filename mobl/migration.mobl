module mobl::migration

load js/persistence.migrations.js

external type Migration {
  static sync function defineMigration(version : Num, steps : Callback) : void
  static sync function createEntity(name : String) : void
  static sync function removeEntity(name : String) : void
  static sync function addProperty(ent : String, prop : String, type : String, defaultValue : Object = null) : void
  static sync function addManyToMany(fromEnt : String, prop : String, toEnt : String) : void
  static sync function removeProperty(ent : String, prop : String) : void
  static sync function addIndex(ent : String, prop : String) : void
  static sync function removeIndex(ent : String, prop : String) : void
  static sync function executeSql(sql : String) : void
}

<javascript for=Migration>
var stepBuffer;
__ns.Migration = {
  defineMigration: function(version, cb) {
    stepBuffer = [];
    cb();
    var steps = stepBuffer.slice(0);
    persistence.defineMigration(version, {
      up: function() {
        var that = this;
        steps.forEach(function(step) {
          that[step[0]].apply(that, step.slice(1));
        });
      },
      down: function() {}
    });
  },
  createEntity: function(name) {
    stepBuffer.push(['createTable', name.replace(/::/g, "__"), function() {}]);
  },
  removeEntity: function(name) {
    stepBuffer.push(['dropTable', name.replace(/::/g, "__")]);
  },
  addProperty: function(ent, name, type, defaultValue) {
    switch(type) {
      case "String": type = "TEXT"; break;
      case "mobl::String": type = "TEXT"; break;
      case "Num": type = "INT"; break;
      case "mobl::Num": type = "INT"; break;
      case "Bool": type = "TINYINT";  defaultValue = defaultValue ? 1 : 0; break;
      case "mobl::Bool": type = "TINYINT";  defaultValue = defaultValue ? 1 : 0; break;
      case "JSON": type = "TEXT"; break;
      case "mobl::JSON": type = "TEXT"; break;
    }
    stepBuffer.push(['addColumn', ent.replace(/::/g, "__"), name, type.replace(/::/g, "__"), defaultValue]);
  },
  addManyToMany: function(fromEnt, prop, toEnt, invProp) {
    fromEnt = fromEnt.replace(/::/g, "");
    toEnt = toEnt.replace(/::/, g);
    var tableName = fromEnt + "_" + prop + "_" + toEnt;
    var inverseTableName = toEnt + '_' + invProp + '_' + fromEnt;

    if (tableName > inverseTableName) {
      // Some arbitrary way to deterministically decide which table to generate
      tableName = inverseTableName;
    }
    stepBuffer.push(['createTable', tableName, function(t) {
      t.text(fromEnt + '_' + prop);
      t.text(toEnt + '_' + invProp);
    }]);
  },
  removeProperty: function(ent, name, type) {
    stepBuffer.push(['removeColumn', ent.replace(/::/g, "__"), name]);
  },
  addIndex: function(ent, name) {
    stepBuffer.push(['addIndex', ent.replace(/::/g, "__"), name]);
  },
  removeIndex: function(ent, name) {
    stepBuffer.push(['removeIndex', ent.replace(/::/g, "__"), name]);
  },
  executeSql: function(sql) {
    stepBuffer.push(['executeSql', sql]);
  }
};

__ns.performMigration = function(callback) {
  persistence.migrations.init(function() {
    persistence.migrate(callback);
  });
};
</javascript>
